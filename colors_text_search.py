#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Описание:на вход подается файл .txt в utf-8 с любым художественным произведением, а на выходе получаем частотную
характеристику использования цветов в произведении и в частях речи.
На выходе (в порядке убывания частоты цвета):
желтый - x1,
    глагол - x11,
    существительно - x12,
    прилагательное - x13
    причастие - x14
    деепричастие - x15
    наречие -16
красный - x2,
    глагол - x21
    существительно - x22
    ...
...

Характеристика цвета может использоваться как в существительных ("чернота", "синева") и прилагательных ("черный",
"синий"), так и в других частях речи ("посинев", "побелел").

Подход к решению:
Идея такова - для каждого цвета найти корень слова, путем отбрасывания окончаний -ый, -ий, -ой, -овый, -евый. Все прочbе
цвета считаются совпадающими с корнем. Для теста словарь с исходными цетами набирается руками.
Открываем файлик, читаем строку, очищаем её от прочих символов, разбиваем на отдельные слова. Смотрим, встречается ли
корень конкретного цвета в этом слове. Если встречается, находим часть речи этого слова и увеличиваем соответствующие
счётчик. И так далее...

Задача стояла в демонстрации подхода к решению. Не учтено е - ё в названиях цветов. Анализ на корень крайне груб -
роверяется простое вхождение. Способ исправления - сделать  анализ приставок, чтобы точнее обнаруживать однокоренные
слова: отличать "посиневший" от "апельсин".

В качестве произведения для проверки был взят роман Айн Рэнд "Атлант расправил плечи" (книга 1).


"""


import codecs
import re
import pymorphy2

morph = pymorphy2.MorphAnalyzer()
delete = re.compile(u'\W+?|\d+?', re.UNICODE)
source_file = r'/Users/atlas_shrugged.txt'

list_of_colors = [u'красный', u'оранжевый', u'желтый', u'вишневый',
                  u'зеленый' , u'голубой', u'синий', u'бежевый',
                  u'фиолетовый', u'серый', u'черный', u'белый']

dic = {key:{'VERB':0,'NOUN':0, 'ADJF':0, 'PRTF':0, 'GRND':0, 'ADVB':0, 'INFN':0,\
            'ADJS':0, 'COMP':0, 'COUNT':0} for key in list_of_colors}


""" возвращает корень слов, обозначающих цвет, путем отбрасывания окончаний """
def get_root(s):
    if s.find (u'ый',-2) !=-1 or s.find (u'ий', -2)!=-1 or s.find (u'ой', -2)!=-1:
        s = s[:-2:]
    elif s.find(u'овый',-4) or s.find(u'евый',-4) !=-1:
        s = s[:-4:]
    return s
    
"""формирует словарь {корень : цвет}"""    
dic_of_roots = {get_root(color):color for color in list_of_colors}
        

with codecs.open(source_file, encoding='utf-8') as f:
    for line in f.readlines():
        line = delete.sub(' ', line)
        line = line.split()
        for root in dic_of_roots.keys():
            for word in line:
                if word.find(root)!=-1:
                    m = morph.parse(word)[0]
                    pos = m.tag.POS
                    dic[dic_of_roots[root]][pos]+=1
                    dic[dic_of_roots[root]]['COUNT']+=1


"""
для вывода в порядке убывания частоты употребления цвета в тексте	
создаем  из словаря лист туплей [(цвет,{часть речи : number, ..., COUNT:number})]
и сортируем этот лист по убывания COUNT	
"""		
new_list = [(key,dic[key]) for key in dic.keys()]
new_list = sorted(new_list,key = lambda a: a[1]['COUNT'], reverse = True)


for item in new_list:
    print item[0], dic[item[0]]['COUNT']
    print '\t глагол', dic[item[0]]['VERB'] + dic[item[0]]['INFN']
    print '\t существительное', dic[item[0]]['NOUN']
    print '\t прилагательное', dic[item[0]]['ADJF']+dic[item[0]]['COMP']+dic[item[0]]['ADJS']
    print '\t причастие', dic[item[0]]['PRTF']
    print '\t деепричастие', dic[item[0]]['GRND']
    print '\t наречие', dic[item[0]]['ADVB']
